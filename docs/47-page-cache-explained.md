# Page Cache 详解 - 磁盘文件缓存机制

> Page Cache 是 Linux 内核用来缓存磁盘文件内容的内存区域

---

## 1. Page Cache 是什么？

### 基本定义

```
Page Cache = 文件内容的内存缓存

作用：
- 缓存磁盘文件的内容到内存
- 避免重复的磁盘 IO
- 加速文件读写操作

位置：内核空间的内存
单位：页面（Page，通常 4KB）
```

### Page Cache 缓存的内容

```
✓ Page Cache 缓存的内容：

1. 普通文件的内容
   ┌────────────────────────────────────┐
   │ 磁盘文件：/home/user/file.txt        │
   │ 内容："Hello World\n"               │
   └────────────────────────────────────┘
            ↓ 读取时
   ┌────────────────────────────────────┐
   │ Page Cache 缓存：                   │
   │ 文件：/home/user/file.txt           │
   │ 内容："Hello World\n" （内存中）      │
   └────────────────────────────────────┘

2. 共享库文件（.so）
   - /lib/x86_64-linux-gnu/libc.so.6
   - 缓存代码段和数据段

3. 可执行文件
   - /usr/bin/python3
   - 缓存程序代码

4. 数据库文件
   - /var/lib/mysql/database.db
   - 缓存数据库数据页

5. 日志文件
   - /var/log/syslog
   - 缓存日志内容

✗ Page Cache 不缓存：
- 设备文件（如 /dev/sda）
- 管道（pipe）
- Socket 数据
- 匿名内存（malloc分配的内存）
```

---

## 2. Page Cache 的工作原理

### 2.1 文件读取时的 Page Cache

```
场景：读取文件 /home/user/data.txt

第一次读取（Page Cache 未命中）：
┌─────────────────────────────────────────────────────────┐
│ 1. 应用程序调用 read()                                    │
│    fd = open("/home/user/data.txt", O_RDONLY);          │
│    read(fd, buf, 4096);                                 │
└─────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 内核查找 Page Cache                                   │
│    - 查找键：(文件inode, 页面偏移)                         │
│    - 结果：未找到（Cache Miss）                            │
└─────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 内核从磁盘读取数据                                      │
│    ┌──────────┐                                         │
│    │  磁盘     │                                         │
│    │ Block #0 │ ─── DMA读取 ───→                         │
│    └──────────┘                                         │
└─────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────┐
│ 4. 数据写入 Page Cache                                   │
│    ┌─────────────────────────────────────────┐          │
│    │ Page Cache                              │          │
│    │ ┌──────────────────────────┐            │          │
│    │ │ 文件: /home/user/data.txt │            │          │
│    │ │ inode: 12345             │            │          │
│    │ │ 页面偏移: 0               │            │          │
│    │ │ 内容: [4096字节文件数据]    │ ← 缓存在这里│          │
│    │ └──────────────────────────┘            │          │
│    └─────────────────────────────────────────┘          │
└─────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────┐
│ 5. 数据拷贝到用户空间                                      │
│    Page Cache → 用户缓冲区 buf                            │
└─────────────────────────────────────────────────────────┘


第二次读取（Page Cache 命中）：
┌─────────────────────────────────────────────────────────┐
│ 1. 应用程序再次调用 read()                               │
│    read(fd, buf, 4096);                                 │
└─────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 内核查找 Page Cache                                   │
│    - 查找键：(文件inode 12345, 页面偏移 0)                │
│    - 结果：找到了！（Cache Hit）                         │
│    ┌────────────────────────────────────────┐           │
│    │ Page Cache                             │           │
│    │ ┌────────────────────────────────┐     │           │
│    │ │ 文件: /home/user/data.txt       │     │           │
│    │ │ inode: 12345                   │     │           │
│    │ │ 页面偏移: 0                     │     │           │
│    │ │ 内容: [4096字节文件数据]        │ ← 直接读取      │
│    │ └────────────────────────────────┘     │           │
│    └────────────────────────────────────────┘           │
└─────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 直接拷贝到用户空间（无需磁盘IO）                       │
│    Page Cache → 用户缓冲区 buf                           │
│    速度快：~1-10 μs（vs 磁盘IO: 1-10 ms）                │
└─────────────────────────────────────────────────────────┘

性能对比：
- 第一次读取：1-10 ms（磁盘IO）
- 第二次读取：1-10 μs（内存访问）
- 速度提升：1000倍！
```

### 2.2 Page Cache 的数据结构

```c
// Linux 内核中 Page Cache 的核心数据结构

// 每个打开的文件都有一个 address_space 结构
struct address_space {
    struct inode *host;           // 关联的 inode（文件）
    struct radix_tree_root page_tree; // 页面树（用于快速查找）
    spinlock_t tree_lock;         // 保护页面树的锁
    unsigned long nrpages;        // 缓存的页面数量
    // ...
};

// 每个缓存的页面
struct page {
    unsigned long flags;          // 页面状态标志
    atomic_t _refcount;           // 引用计数
    atomic_t _mapcount;           // 映射计数

    struct address_space *mapping; // 关联的 address_space
    pgoff_t index;                // 页面在文件中的偏移（以页为单位）

    struct list_head lru;         // LRU 链表节点
    void *virtual;                // 虚拟地址
    // ...
};

内存布局：
┌────────────────────────────────────────────────────────┐
│                   文件 inode                            │
│  ┌──────────────────────────────────────────────┐      │
│  │ struct inode {                               │      │
│  │   i_ino = 12345;           // inode 号       │      │
│  │   i_size = 100MB;          // 文件大小       │      │
│  │   i_mapping = &address_space; // 指向缓存    │ ─┐   │
│  │ }                                            │  │   │
│  └──────────────────────────────────────────────┘  │   │
└────────────────────────────────────────────────────┼───┘
                                                     ↓
┌────────────────────────────────────────────────────────┐
│              address_space（文件的缓存区）              │
│  ┌──────────────────────────────────────────────┐      │
│  │ struct address_space {                       │      │
│  │   host = inode;            // 指向 inode     │      │
│  │   nrpages = 25600;         // 100MB/4KB      │      │
│  │   page_tree = {            // 页面索引树     │      │
│  │     ...                                      │      │
│  │   }                                          │      │
│  │ }                                            │      │
│  └──────────────────────────────────────────────┘      │
│                      ↓                                 │
│  ┌──────────────────────────────────────────────┐      │
│  │         Radix Tree（基数树，快速查找）        │      │
│  │                                              │      │
│  │       Root                                   │      │
│  │         ├─ 0-1023   ─→ [page 0...1023]      │      │
│  │         ├─ 1024-2047 ─→ [page 1024...2047]  │      │
│  │         └─ ...                               │      │
│  └──────────────────────────────────────────────┘      │
│                      ↓                                 │
│  具体页面缓存：                                         │
│  ┌────────────────────────────────┐                    │
│  │ Page #0 (偏移 0-4KB)           │                    │
│  │ [文件前4KB内容]                 │                    │
│  └────────────────────────────────┘                    │
│  ┌────────────────────────────────┐                    │
│  │ Page #1 (偏移 4KB-8KB)         │                    │
│  │ [文件4KB-8KB内容]               │                    │
│  └────────────────────────────────┘                    │
│  ...                                                   │
│  ┌────────────────────────────────┐                    │
│  │ Page #25599 (偏移 ~100MB)      │                    │
│  │ [文件最后4KB内容]               │                    │
│  └────────────────────────────────┘                    │
└────────────────────────────────────────────────────────┘
```

### 2.3 Page Cache 查找过程（内核代码）

```c
// mm/filemap.c - Page Cache 查找核心函数

struct page *find_get_page(struct address_space *mapping, pgoff_t offset)
{
    struct page *page;

    // 1. 在 radix tree 中查找页面
    rcu_read_lock();
    page = radix_tree_lookup(&mapping->page_tree, offset);

    if (page) {
        // 2. 找到了！增加引用计数（防止被回收）
        if (!page_cache_get_speculative(page))
            goto repeat;

        // 3. 检查页面是否仍然有效
        if (unlikely(page->mapping != mapping || page->index != offset)) {
            put_page(page);
            goto repeat;
        }
    }
    rcu_read_unlock();

    return page;  // 返回缓存的页面（或 NULL）
}

使用示例：
// 读取文件时的代码路径
ssize_t generic_file_read(..., loff_t *ppos)
{
    struct address_space *mapping = file->f_mapping;
    pgoff_t index = *ppos >> PAGE_SHIFT;  // 计算页面索引

    // 查找 Page Cache
    struct page *page = find_get_page(mapping, index);

    if (!page) {
        // Cache Miss：从磁盘读取
        page = page_cache_alloc(mapping);
        add_to_page_cache_lru(page, mapping, index);

        // 触发磁盘 IO
        mapping->a_ops->readpage(file, page);

        // 等待 IO 完成
        wait_on_page_locked(page);
    }

    // Cache Hit：直接使用缓存的数据
    void *kaddr = kmap_atomic(page);
    copy_to_user(buf, kaddr + offset, len);
    kunmap_atomic(kaddr);

    put_page(page);  // 减少引用计数
}
```

---

## 3. Page Cache 缓存的具体内容示例

### 示例1：文本文件

```
磁盘文件：/home/user/hello.txt
内容（100字节）：
┌──────────────────────────────────────┐
│ Hello, World!                        │
│ This is a test file.                 │
│ Page Cache demonstration.            │
└──────────────────────────────────────┘

Page Cache 中的缓存：
┌──────────────────────────────────────────────────────┐
│ inode: 67890                                         │
│ 页面偏移: 0（第一个4KB页面）                          │
│ ┌────────────────────────────────────────────────┐   │
│ │ 字节 0-99:                                      │   │
│ │   Hello, World!                                │   │
│ │   This is a test file.                         │   │
│ │   Page Cache demonstration.                    │   │
│ │                                                │   │
│ │ 字节 100-4095:                                  │   │
│ │   [空数据 / 0x00]                              │   │
│ └────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────┘

注意：即使文件只有100字节，Page Cache也会分配整个4KB页面
```

### 示例2：二进制可执行文件

```
磁盘文件：/usr/bin/ls （假设大小 128KB）
内容：ELF 可执行文件

Page Cache 中的缓存：
┌──────────────────────────────────────────────────────┐
│ inode: 123456                                        │
│ ┌────────────────────────────────────────────────┐   │
│ │ 页面 #0 (偏移 0-4KB):                           │   │
│ │   ELF Header                                   │   │
│ │   Program Headers                              │   │
│ │   [二进制代码开头]                              │   │
│ └────────────────────────────────────────────────┘   │
│ ┌────────────────────────────────────────────────┐   │
│ │ 页面 #1 (偏移 4KB-8KB):                         │   │
│ │   [二进制代码]                                  │   │
│ │   x86_64 机器码: 0x48 0x8b 0x05 ...           │   │
│ └────────────────────────────────────────────────┘   │
│ ...                                                  │
│ ┌────────────────────────────────────────────────┐   │
│ │ 页面 #31 (偏移 124KB-128KB):                    │   │
│ │   [二进制代码结尾]                              │   │
│ │   符号表、字符串表                              │   │
│ └────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────┘

当执行 /usr/bin/ls 时：
- 程序代码从 Page Cache 加载（而不是每次从磁盘读取）
- 多个进程执行同一程序，共享同一 Page Cache
```

### 示例3：数据库文件

```
磁盘文件：/var/lib/mysql/users.ibd （InnoDB 表空间）
内容：数据库表的数据页

Page Cache 中的缓存：
┌──────────────────────────────────────────────────────┐
│ inode: 789012                                        │
│ ┌────────────────────────────────────────────────┐   │
│ │ 页面 #0 (偏移 0-4KB):                           │   │
│ │   InnoDB Page Header                           │   │
│ │   ┌──────────────────────────────────────┐     │   │
│ │   │ Page Type: B-Tree Index              │     │   │
│ │   │ Page Number: 0                       │     │   │
│ │   │ LSN: 123456789                       │     │   │
│ │   └──────────────────────────────────────┘     │   │
│ │   ┌──────────────────────────────────────┐     │   │
│ │   │ 用户记录:                             │     │   │
│ │   │   ID=1, Name="Alice", Age=30         │     │   │
│ │   │   ID=2, Name="Bob", Age=25           │     │   │
│ │   │   ...                                │     │   │
│ │   └──────────────────────────────────────┘     │   │
│ └────────────────────────────────────────────────┘   │
│ ┌────────────────────────────────────────────────┐   │
│ │ 页面 #1 (偏移 4KB-8KB):                         │   │
│ │   更多用户记录...                               │   │
│ └────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────┘

MySQL 读取数据时：
1. 先查 MySQL Buffer Pool（应用层缓存）
2. 未命中则查 Page Cache（内核缓存）
3. 再未命中才读磁盘

双重缓存机制！
```

---

## 4. Page Cache 的生命周期

### 4.1 页面写入 Page Cache

```
写入流程：
┌─────────────────────────────────────────────────────────┐
│ 1. 应用程序写入数据                                      │
│    fd = open("file.txt", O_WRONLY);                     │
│    write(fd, "Hello", 5);                               │
└─────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 数据写入 Page Cache（标记为"脏页"）                   │
│    ┌────────────────────────────────────────┐           │
│    │ Page Cache                             │           │
│    │ ┌────────────────────────────────┐     │           │
│    │ │ 文件: file.txt                  │     │           │
│    │ │ 内容: "Hello"                  │     │           │
│    │ │ 标志: PG_dirty（脏页）          │ ← 标记为脏     │
│    │ └────────────────────────────────┘     │           │
│    └────────────────────────────────────────┘           │
│                                                         │
│    write() 立即返回（异步写入）                          │
└─────────────────────────────────────────────────────────┘
        ↓ （稍后，由内核后台线程处理）
┌─────────────────────────────────────────────────────────┐
│ 3. 内核后台线程（pdflush/flush）将脏页写回磁盘           │
│    触发条件：                                            │
│    - 脏页太多（超过阈值，如10%内存）                      │
│    - 脏页存在时间过长（默认30秒）                         │
│    - 用户调用 sync() / fsync()                          │
│    - 系统关机                                           │
│                                                         │
│    ┌────────────────────────────────────────┐           │
│    │ Page Cache (脏页)                      │           │
│    │ [数据: "Hello"]                        │           │
│    └────────────────────────────────────────┘           │
│            ↓ 后台线程写回                               │
│    ┌────────────────────────────────────────┐           │
│    │ 磁盘 file.txt                          │           │
│    │ [数据: "Hello"]                        │           │
│    └────────────────────────────────────────┘           │
│                                                         │
│    写回完成后，清除 PG_dirty 标志                         │
└─────────────────────────────────────────────────────────┘
```

### 4.2 页面回收（Page Reclaim）

```
当内存不足时，内核需要回收 Page Cache：

LRU（Least Recently Used）算法：
┌──────────────────────────────────────────────────────┐
│                   LRU 链表                            │
│                                                      │
│  最近访问 ←──────────────────────────── 最久未访问    │
│     ↓                                        ↓        │
│  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐        │
│  │Page1│→│Page2│→│Page3│→│Page4│→│Page5│        │
│  └─────┘  └─────┘  └─────┘  └─────┘  └─────┘        │
│   活跃      活跃      中等      冷门      冷门         │
└──────────────────────────────────────────────────────┘

回收策略：
1. 优先回收"冷门"页面（Page5, Page4）
2. 如果是脏页，先写回磁盘
3. 如果页面被引用（refcount > 0），跳过
4. 清理页面，释放内存

代码示例（简化）：
// mm/vmscan.c
static unsigned long shrink_page_list(struct list_head *page_list)
{
    while (!list_empty(page_list)) {
        page = lru_to_page(page_list);

        // 1. 检查是否可以回收
        if (page_mapped(page) && page_referenced(page)) {
            // 页面最近被访问，移到活跃列表
            list_move(&page->lru, &active_list);
            continue;
        }

        // 2. 如果是脏页，写回磁盘
        if (PageDirty(page)) {
            pageout(page);  // 写回磁盘
            continue;
        }

        // 3. 回收页面
        __remove_mapping(mapping, page);
        free_hot_cold_page(page, 0);
        nr_reclaimed++;
    }

    return nr_reclaimed;
}
```

---

## 5. Page Cache 相关的系统调用

### 5.1 fsync() - 强制写回脏页

```c
// 确保数据真正写入磁盘（而不只是在 Page Cache 中）

int fd = open("file.txt", O_WRONLY);
write(fd, data, size);  // 数据在 Page Cache 中（脏页）

// 强制写回磁盘
fsync(fd);  // 阻塞，直到数据真正写入磁盘

// 类似的系统调用：
sync();       // 写回所有文件系统的脏页
fdatasync();  // 类似 fsync，但不更新元数据（更快）

数据库通常使用 fsync 保证持久化：
write(log_fd, transaction_log, size);
fsync(log_fd);  // 确保事务日志持久化
```

### 5.2 posix_fadvise() - 控制 Page Cache 行为

```c
#include <fcntl.h>

int fd = open("bigfile.dat", O_RDONLY);

// 1. 顺序读取优化（预读更多数据）
posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);
// 内核会增加预读窗口，一次读取 128KB 而不是 4KB

// 2. 随机读取优化（减少预读）
posix_fadvise(fd, 0, 0, POSIX_FADV_RANDOM);
// 内核会减少或禁用预读

// 3. 不需要缓存（读取后立即释放 Page Cache）
posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED);
// 用于一次性读取大文件，避免污染 Page Cache

// 4. 需要数据（预加载到 Page Cache）
posix_fadvise(fd, 0, 100*1024*1024, POSIX_FADV_WILLNEED);
// 预先将 100MB 数据加载到 Page Cache
```

### 5.3 mmap() - 直接映射 Page Cache

```c
// mmap 不拷贝数据，而是直接映射 Page Cache 到用户空间

int fd = open("file.txt", O_RDONLY);
struct stat st;
fstat(fd, &st);

// 映射文件到用户空间
void *addr = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0);

// 直接访问文件内容（无需 read()）
char first_byte = ((char*)addr)[0];  // 直接读取 Page Cache

// 如果 Page Cache 未命中，触发缺页中断，从磁盘读取

内存布局：
┌──────────────────────────────────────────────────┐
│ 用户空间虚拟地址：0x7f1234000000                  │
│     ↓ 映射                                       │
│ ┌────────────────────────────────────┐           │
│ │ Page Cache                         │           │
│ │ [文件内容]                          │           │
│ └────────────────────────────────────┘           │
└──────────────────────────────────────────────────┘

优点：
✓ 零拷贝（用户空间直接访问 Page Cache）
✓ 多进程共享（节省内存）

缺点：
✗ 缺页中断开销（首次访问需要从磁盘读取）
```

---

## 6. Page Cache 的监控

### 6.1 查看 Page Cache 使用情况

```bash
# 1. free 命令
free -h
#               total        used        free      shared  buff/cache   available
# Mem:            15Gi       2.0Gi       8.0Gi       100Mi       5.0Gi        13Gi
#                                                                  ↑
#                                          Page Cache + Buffer Cache

# buff/cache 包括：
# - Page Cache：文件内容缓存
# - Buffer Cache：磁盘块缓存
# - Slab：内核数据结构缓存


# 2. /proc/meminfo
cat /proc/meminfo | grep -E 'Cached|Dirty|Writeback'
# Cached:          5242880 kB  ← Page Cache 大小
# Dirty:             12345 kB  ← 脏页大小
# Writeback:            12 kB  ← 正在写回的页面


# 3. 查看特定文件在 Page Cache 中的情况
# 安装 pcstat 工具
go install github.com/tobert/pcstat/pcstat@latest

pcstat /path/to/file
# ┌──────────────────────────────────────────────────────┐
# │ File: /var/log/syslog                                │
# │ Size: 10485760 bytes (10 MB)                         │
# │ Pages: 2560 (10MB / 4KB)                             │
# │ Cached: 2560 pages (100%)  ← 全部在 Page Cache 中    │
# │ Uncached: 0 pages (0%)                               │
# └──────────────────────────────────────────────────────┘


# 4. vmstat 监控脏页写回
vmstat 1
# procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
#  r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
#  0  0      0 8388608  51200 5242880  0    0     0   512  100  200  1  1 98  0  0
#                              ↑                      ↑
#                         Page Cache               写回速率 (bo)
```

### 6.2 清空 Page Cache（测试用）

```bash
# 警告：生产环境慎用！会导致性能骤降

# 1. 仅清空 Page Cache
echo 1 > /proc/sys/vm/drop_caches

# 2. 清空 Page Cache 和 dentry/inode 缓存
echo 2 > /proc/sys/vm/drop_caches

# 3. 清空所有缓存
echo 3 > /proc/sys/vm/drop_caches

# 清空后立即读取文件会很慢（需要从磁盘读取）
```

---

## 7. Page Cache 常见问题

### Q1: Page Cache 会无限增长吗？

**答**：不会。Page Cache 使用的是"空闲内存"。

```
内存使用优先级：
1. 应用程序内存（最高优先级，不能被回收）
2. 内核数据结构（高优先级）
3. Page Cache（低优先级，可以被回收）

当应用程序需要更多内存时：
┌──────────────────────────────────────┐
│ 1. 内核检测到内存不足                 │
├──────────────────────────────────────┤
│ 2. 触发 Page Cache 回收               │
│    - 优先回收"冷门"页面               │
│    - 脏页先写回磁盘                   │
├──────────────────────────────────────┤
│ 3. 释放的内存分配给应用程序            │
└──────────────────────────────────────┘

Page Cache 是动态的，自动调整大小
```

### Q2: 写入 Page Cache 后立即断电会丢数据吗？

**答**：会！Page Cache 是内存，断电即丢失。

```
数据持久化保证：

✗ 不安全的方式：
  write(fd, data, size);
  // 数据在 Page Cache（内存）中
  // 断电 → 数据丢失

✓ 安全的方式：
  write(fd, data, size);
  fsync(fd);  // 强制写入磁盘
  // 断电 → 数据安全

数据库事务通常使用 fsync 确保持久化：
BEGIN TRANSACTION;
  INSERT INTO users ...;
  -- 数据库内部调用 fsync(wal_fd) 刷新 WAL 日志
COMMIT;  // 提交后才真正持久化
```

### Q3: 为什么 Linux 内存总是"满"的？

**答**：因为 Linux 充分利用空闲内存作为 Page Cache。

```
常见误解：
free 命令显示：
  used: 12GB
  free: 2GB
  buff/cache: 8GB  ← "这么多缓存，是不是有问题？"

实际情况：
✓ buff/cache 是"可用内存"（可以随时释放）
✓ 真正的可用内存 = free + buff/cache = 10GB
✓ 充分利用内存，提升性能

内存不足时，内核会自动回收 Page Cache
```

---

## 8. 总结

### Page Cache 的核心要点

```
1. Page Cache 缓存什么？
   ✓ 磁盘文件的内容
   ✓ 以 4KB 页面为单位
   ✓ 位于内核空间

2. Page Cache 如何工作？
   读取：
     - 查找 Page Cache（通过 inode + 偏移）
     - 命中 → 直接返回（快）
     - 未命中 → 从磁盘读取 + 缓存

   写入：
     - 写入 Page Cache（标记为脏页）
     - 后台异步写回磁盘
     - fsync() 强制同步

3. Page Cache 的好处？
   ✓ 避免重复磁盘 IO（性能提升 1000 倍）
   ✓ 多进程共享（节省内存）
   ✓ 预读优化（顺序读取更快）

4. Page Cache 的生命周期？
   - 创建：首次读取文件时分配
   - 更新：文件修改时标记脏页
   - 回收：内存不足时 LRU 回收
   - 写回：脏页定期或强制写回磁盘

5. Page Cache vs Buffer Cache？
   - Page Cache：文件内容缓存（本文重点）
   - Buffer Cache：磁盘块缓存（较少使用）
   - 现代 Linux 已合并（统称为 Page Cache）
```

### 性能建议

```
1. 利用 Page Cache：
   ✓ 频繁读取的文件会自动缓存
   ✓ 无需手动管理（内核自动优化）

2. 顺序读取优化：
   ✓ 使用 POSIX_FADV_SEQUENTIAL
   ✓ 内核会增加预读窗口

3. 一次性大文件：
   ✓ 使用 POSIX_FADV_DONTNEED
   ✓ 避免污染 Page Cache

4. 数据持久化：
   ✓ 重要数据使用 fsync()
   ✓ 数据库事务需要 WAL + fsync

5. 监控 Page Cache：
   ✓ 用 free / vmstat 监控
   ✓ 用 pcstat 查看文件缓存率
```

---

**延伸阅读**：
- `man 2 read` - read 系统调用
- `man 2 write` - write 系统调用
- `man 2 fsync` - 强制同步
- `man 2 posix_fadvise` - 缓存控制
- `man 5 proc` - /proc/meminfo 详解

希望这份详细的 Page Cache 解释能帮助你理解它的工作原理！🚀
