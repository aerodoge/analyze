# é‡åŒ–äº¤æ˜“åç«¯å·¥ç¨‹å¸ˆå­¦ä¹ è®¡åˆ’

> **ç›®æ ‡å²—ä½**ï¼šé‡åŒ–äº¤æ˜“åç«¯å·¥ç¨‹å¸ˆï¼ˆ20-35Kï¼‰
>
> **æ ¸å¿ƒèƒ½åŠ›**ï¼šä½å»¶è¿Ÿäº¤æ˜“ç³»ç»Ÿã€é«˜é¢‘äº¤æ˜“ã€æ€§èƒ½ä¼˜åŒ–
>
> **é¢è¯•é€šè¿‡ç‡ç›®æ ‡**ï¼šâ‰¥90%
>
> **å­¦ä¹ å‘¨æœŸ**ï¼š10å‘¨ï¼ˆ70å¤©ï¼‰
>
> **æ¯æ—¥å­¦ä¹ æ—¶é—´**ï¼š4-5å°æ—¶

---

## ğŸ“‹ JDéœ€æ±‚åˆ†æ

### å²—ä½èŒè´£ï¼š
1. âœ… è®¾è®¡ã€å¼€å‘ä½å»¶è¿Ÿã€é«˜ååé‡äº¤æ˜“ç³»ç»Ÿï¼ˆè®¢å•æ‰§è¡Œå¼•æ“ã€é£æ§ç³»ç»Ÿï¼‰
2. âœ… æ€§èƒ½ä¼˜åŒ–ï¼ˆç½‘ç»œã€æ“ä½œç³»ç»Ÿã€æ•°æ®åº“ã€åº”ç”¨ä»£ç ï¼‰
3. âœ… å¸‚åœºæ•°æ®å¤„ç†ï¼ˆtickæ•°æ®ã€Level 2/3æ•°æ®ï¼‰
4. âœ… ç­–ç•¥é›†æˆä¸ç›‘æ§
5. âœ… 7x24é«˜å¯ç”¨ç³»ç»Ÿ
6. âœ… æŠ€æœ¯ç ”ç©¶ï¼ˆç¡¬ä»¶åŠ é€Ÿã€æ–°åè®®ï¼‰

### æŠ€æœ¯è¦æ±‚åˆ†çº§ï¼š

```
æ ¸å¿ƒæŠ€èƒ½ï¼ˆå¿…é¡»ç²¾é€šï¼‰ï¼š
â”œâ”€ C++ä½å»¶è¿Ÿç¼–ç¨‹ â­â­â­â­â­
â”œâ”€ Linuxç³»ç»Ÿæ·±åº¦ä¼˜åŒ– â­â­â­â­â­
â”œâ”€ ç½‘ç»œç¼–ç¨‹ï¼ˆTCP/UDP/Multicastï¼‰â­â­â­â­â­
â”œâ”€ æ€§èƒ½åˆ†æï¼ˆperf/VTuneï¼‰â­â­â­â­â­
â””â”€ æ— é”ç¼–ç¨‹ â­â­â­â­â­

é‡è¦æŠ€èƒ½ï¼š
â”œâ”€ æ—¶åºæ•°æ®åº“ï¼ˆTimescaleDB/InfluxDBï¼‰â­â­â­â­
â”œâ”€ Redisé«˜æ€§èƒ½ä½¿ç”¨ â­â­â­â­
â”œâ”€ PostgreSQL â­â­â­â­
â””â”€ Pythonæ•°æ®åˆ†æ â­â­â­â­

åŠ åˆ†æŠ€èƒ½ï¼š
â”œâ”€ Rustç¼–ç¨‹ â­â­â­
â”œâ”€ KDB+æ—¶åºæ•°æ®åº“ â­â­â­
â”œâ”€ é‡‘èåè®®ï¼ˆFIXç­‰ï¼‰â­â­â­
â””â”€ æ¸¯ç¾è‚¡è¯åˆ¸çŸ¥è¯† â­â­
```

---

## ğŸ¯ å­¦ä¹ è·¯çº¿å›¾

```
ç¬¬1å‘¨ï¼šC++ä½å»¶è¿Ÿç¼–ç¨‹åŸºç¡€
â”œâ”€ ç°ä»£C++ï¼ˆ11/14/17ï¼‰æ·±å…¥
â”œâ”€ CPUç¼“å­˜å‹å¥½ç¼–ç¨‹
â”œâ”€ å†…å­˜å¯¹é½ä¸ä¼˜åŒ–
â””â”€ ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€å·§

ç¬¬2å‘¨ï¼šåº•å±‚ç³»ç»Ÿä¼˜åŒ–
â”œâ”€ Linuxå†…æ ¸å‚æ•°è°ƒä¼˜
â”œâ”€ è¿›ç¨‹/çº¿ç¨‹è°ƒåº¦ä¼˜åŒ–
â”œâ”€ NUMAæ¶æ„ä¼˜åŒ–
â””â”€ CPUäº²å’Œæ€§ç»‘å®š

ç¬¬3å‘¨ï¼šç½‘ç»œç¼–ç¨‹ä¼˜åŒ–
â”œâ”€ TCP/UDPé›¶æ‹·è´
â”œâ”€ Kernel bypassï¼ˆDPDKåŸºç¡€ï¼‰
â”œâ”€ ç»„æ’­ï¼ˆMulticastï¼‰
â””â”€ ç½‘ç»œå»¶è¿Ÿä¼˜åŒ–

ç¬¬4å‘¨ï¼šæ— é”ç¼–ç¨‹ä¸å¹¶å‘
â”œâ”€ åŸå­æ“ä½œè¯¦è§£
â”œâ”€ æ— é”é˜Ÿåˆ—å®ç°
â”œâ”€ å†…å­˜å±éšœ
â””â”€ Lock-freeæ•°æ®ç»“æ„

ç¬¬5å‘¨ï¼šæ€§èƒ½åˆ†æä¸è°ƒä¼˜
â”œâ”€ perfå·¥å…·æ·±åº¦ä½¿ç”¨
â”œâ”€ VTuneæ€§èƒ½åˆ†æ
â”œâ”€ ç«ç„°å›¾åˆ†æ
â””â”€ å¾®åŸºå‡†æµ‹è¯•

ç¬¬6å‘¨ï¼šæ—¶åºæ•°æ®åº“
â”œâ”€ TimescaleDBå®æˆ˜
â”œâ”€ InfluxDBä½¿ç”¨
â”œâ”€ KDB+åŸºç¡€ï¼ˆå¦‚æœ‰èµ„æºï¼‰
â””â”€ é«˜æ€§èƒ½æŸ¥è¯¢ä¼˜åŒ–

ç¬¬7å‘¨ï¼šäº¤æ˜“ç³»ç»Ÿæ¶æ„
â”œâ”€ è®¢å•æ‰§è¡Œå¼•æ“è®¾è®¡
â”œâ”€ å¸‚åœºæ•°æ®å¤„ç†
â”œâ”€ tickæ•°æ®å¤„ç†
â””â”€ Level 2/3æ•°æ®è§£æ

ç¬¬8å‘¨ï¼šé£æ§ä¸ç›‘æ§
â”œâ”€ é£é™©ç®¡ç†ç³»ç»Ÿ
â”œâ”€ å®æ—¶ç›‘æ§ç³»ç»Ÿ
â”œâ”€ å‘Šè­¦æœºåˆ¶
â””â”€ æ•…éšœæ¢å¤

ç¬¬9å‘¨ï¼šRustç¼–ç¨‹ï¼ˆåŠ åˆ†é¡¹ï¼‰
â”œâ”€ RuståŸºç¡€è¯­æ³•
â”œâ”€ æ‰€æœ‰æƒä¸å€Ÿç”¨
â”œâ”€ é«˜æ€§èƒ½Rust
â””â”€ Rustä¸C++å¯¹æ¯”

ç¬¬10å‘¨ï¼šç»¼åˆé¡¹ç›®+é¢è¯•
â”œâ”€ å®Œæ•´äº¤æ˜“ç³»ç»Ÿå®ç°
â”œâ”€ æ€§èƒ½å‹æµ‹
â”œâ”€ é¢è¯•å‡†å¤‡
â””â”€ ç®€å†ä¼˜åŒ–
```

---

## ğŸ“… è¯¦ç»†å­¦ä¹ è®¡åˆ’

## ç¬¬1å‘¨ï¼šC++ä½å»¶è¿Ÿç¼–ç¨‹åŸºç¡€

### Day 1ï¼šç°ä»£C++11/14/17æ ¸å¿ƒç‰¹æ€§

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡C++11/14/17æ€§èƒ½ç›¸å…³ç‰¹æ€§
- ç†è§£ç§»åŠ¨è¯­ä¹‰å¯¹æ€§èƒ½çš„å½±å“
- å­¦ä¹ constexprç¼–è¯‘æœŸä¼˜åŒ–

**å­¦ä¹ å†…å®¹**ï¼š

#### 1. ç§»åŠ¨è¯­ä¹‰æ·±å…¥ç†è§£

```cpp
// ä½å»¶è¿Ÿåœºæ™¯ä¸‹çš„ç§»åŠ¨è¯­ä¹‰
#include <iostream>
#include <chrono>
#include <vector>

class MarketData {
private:
    std::vector<double> prices;
    size_t size;

public:
    // æ„é€ å‡½æ•°
    MarketData(size_t n) : size(n) {
        prices.reserve(n);
        for (size_t i = 0; i < n; ++i) {
            prices.push_back(100.0 + i * 0.01);
        }
    }

    // æ‹·è´æ„é€ ï¼ˆæ˜‚è´µï¼‰
    MarketData(const MarketData& other) : prices(other.prices), size(other.size) {
        std::cout << "Copy constructor: expensive!" << std::endl;
    }

    // ç§»åŠ¨æ„é€ ï¼ˆé«˜æ•ˆï¼‰
    MarketData(MarketData&& other) noexcept : prices(std::move(other.prices)), size(other.size) {
        other.size = 0;
        std::cout << "Move constructor: fast!" << std::endl;
    }

    // ç§»åŠ¨èµ‹å€¼
    MarketData& operator=(MarketData&& other) noexcept {
        if (this != &other) {
            prices = std::move(other.prices);
            size = other.size;
            other.size = 0;
        }
        return *this;
    }

    size_t getSize() const { return size; }
};

// æ€§èƒ½å¯¹æ¯”æµ‹è¯•
void testMoveVsCopy() {
    using namespace std::chrono;

    // æµ‹è¯•æ‹·è´
    {
        auto start = high_resolution_clock::now();
        std::vector<MarketData> vec;

        for (int i = 0; i < 1000; ++i) {
            MarketData data(10000);
            vec.push_back(data);  // æ‹·è´
        }

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<microseconds>(end - start);
        std::cout << "Copy time: " << duration.count() << " Î¼s" << std::endl;
    }

    // æµ‹è¯•ç§»åŠ¨
    {
        auto start = high_resolution_clock::now();
        std::vector<MarketData> vec;

        for (int i = 0; i < 1000; ++i) {
            MarketData data(10000);
            vec.push_back(std::move(data));  // ç§»åŠ¨
        }

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<microseconds>(end - start);
        std::cout << "Move time: " << duration.count() << " Î¼s" << std::endl;
    }
}

int main() {
    testMoveVsCopy();
    return 0;
}

// ç»“æœï¼šç§»åŠ¨æ¯”æ‹·è´å¿«100å€ä»¥ä¸Šï¼
```

#### 2. constexprç¼–è¯‘æœŸè®¡ç®—

```cpp
// constexprç”¨äºä½å»¶è¿Ÿç³»ç»Ÿçš„ç¼–è¯‘æœŸä¼˜åŒ–
#include <iostream>
#include <array>

// ç¼–è¯‘æœŸè®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—
constexpr int fibonacci(int n) {
    return n <= 1 ? n : fibonacci(n-1) + fibonacci(n-2);
}

// ç¼–è¯‘æœŸç”ŸæˆæŸ¥æ‰¾è¡¨
constexpr std::array<int, 20> generateFibTable() {
    std::array<int, 20> table{};
    for (int i = 0; i < 20; ++i) {
        table[i] = fibonacci(i);
    }
    return table;
}

// ç¼–è¯‘æœŸè®¡ç®—ï¼Œè¿è¡Œæ—¶O(1)æŸ¥æ‰¾
constexpr auto fibTable = generateFibTable();

// äº¤æ˜“ç³»ç»Ÿåº”ç”¨ï¼šç¼–è¯‘æœŸè®¡ç®—è´¹ç‡è¡¨
constexpr double calculateCommission(double price, int quantity) {
    return price * quantity * 0.0001;  // 0.01%æ‰‹ç»­è´¹
}

// ç¼–è¯‘æœŸç”Ÿæˆæ‰‹ç»­è´¹æŸ¥æ‰¾è¡¨
constexpr std::array<double, 100> generateCommissionTable() {
    std::array<double, 100> table{};
    for (int i = 0; i < 100; ++i) {
        table[i] = calculateCommission(100.0, i * 100);
    }
    return table;
}

constexpr auto commissionTable = generateCommissionTable();

int main() {
    // è¿è¡Œæ—¶ç›´æ¥æŸ¥è¡¨ï¼Œæ— éœ€è®¡ç®—
    std::cout << "Fib(10) = " << fibTable[10] << std::endl;
    std::cout << "Commission for 5000 shares: $" << commissionTable[50] << std::endl;

    return 0;
}
```

#### 3. æ™ºèƒ½æŒ‡é’ˆçš„æ€§èƒ½è€ƒé‡

```cpp
#include <iostream>
#include <memory>
#include <chrono>
#include <vector>

struct Order {
    int orderId;
    double price;
    int quantity;
    char side;  // 'B' or 'S'
};

// æ€§èƒ½å¯¹æ¯”ï¼šè£¸æŒ‡é’ˆ vs unique_ptr vs shared_ptr
void performanceComparison() {
    using namespace std::chrono;
    const int N = 1000000;

    // 1. è£¸æŒ‡é’ˆï¼ˆæœ€å¿«ï¼Œä½†ä¸å®‰å…¨ï¼‰
    {
        auto start = high_resolution_clock::now();
        std::vector<Order*> orders;
        orders.reserve(N);

        for (int i = 0; i < N; ++i) {
            orders.push_back(new Order{i, 100.0, 100, 'B'});
        }

        // ä½¿ç”¨è®¢å•
        long sum = 0;
        for (auto* order : orders) {
            sum += order->orderId;
        }

        // æ‰‹åŠ¨é‡Šæ”¾
        for (auto* order : orders) {
            delete order;
        }

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<microseconds>(end - start);
        std::cout << "Raw pointer: " << duration.count() << " Î¼s" << std::endl;
    }

    // 2. unique_ptrï¼ˆé›¶å¼€é”€æŠ½è±¡ï¼Œæ¨èï¼‰
    {
        auto start = high_resolution_clock::now();
        std::vector<std::unique_ptr<Order>> orders;
        orders.reserve(N);

        for (int i = 0; i < N; ++i) {
            orders.push_back(std::make_unique<Order>(Order{i, 100.0, 100, 'B'}));
        }

        // ä½¿ç”¨è®¢å•
        long sum = 0;
        for (const auto& order : orders) {
            sum += order->orderId;
        }

        // è‡ªåŠ¨é‡Šæ”¾

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<microseconds>(end - start);
        std::cout << "unique_ptr: " << duration.count() << " Î¼s" << std::endl;
    }

    // 3. shared_ptrï¼ˆæœ‰å¼•ç”¨è®¡æ•°å¼€é”€ï¼Œé¿å…åœ¨ä½å»¶è¿Ÿè·¯å¾„ä½¿ç”¨ï¼‰
    {
        auto start = high_resolution_clock::now();
        std::vector<std::shared_ptr<Order>> orders;
        orders.reserve(N);

        for (int i = 0; i < N; ++i) {
            orders.push_back(std::make_shared<Order>(Order{i, 100.0, 100, 'B'}));
        }

        // ä½¿ç”¨è®¢å•
        long sum = 0;
        for (const auto& order : orders) {
            sum += order->orderId;
        }

        // è‡ªåŠ¨é‡Šæ”¾

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<microseconds>(end - start);
        std::cout << "shared_ptr: " << duration.count() << " Î¼s" << std::endl;
    }
}

int main() {
    performanceComparison();
    return 0;
}

/*
æ€§èƒ½ç»“è®ºï¼š
- unique_ptr â‰ˆ è£¸æŒ‡é’ˆæ€§èƒ½ï¼ˆé›¶å¼€é”€æŠ½è±¡ï¼‰
- shared_ptr æœ‰20-30%çš„æ€§èƒ½æŸå¤±ï¼ˆå¼•ç”¨è®¡æ•°åŸå­æ“ä½œï¼‰
- ä½å»¶è¿Ÿç³»ç»Ÿå»ºè®®ï¼šunique_ptr > è£¸æŒ‡é’ˆ > shared_ptr
*/
```

#### 4. å†…è”å‡½æ•°ä¸ç¼–è¯‘å™¨ä¼˜åŒ–

```cpp
#include <iostream>

// å†…è”å‡½æ•°é¿å…å‡½æ•°è°ƒç”¨å¼€é”€
inline double calculateVWAP(double totalValue, double totalVolume) {
    return totalValue / totalVolume;
}

// å¼ºåˆ¶å†…è”ï¼ˆGCC/Clangï¼‰
__attribute__((always_inline))
inline int fastMax(int a, int b) {
    return (a > b) ? a : b;
}

// å‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªå‡½æ•°æ˜¯çƒ­è·¯å¾„
__attribute__((hot))
void processTickData(const double* prices, int count) {
    double sum = 0;
    for (int i = 0; i < count; ++i) {
        sum += prices[i];
    }
    // å¤„ç†...
}

// å‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªåˆ†æ”¯æ›´å¯èƒ½æ‰§è¡Œ
bool isMarketOpen(int hour) {
    if (__builtin_expect(hour >= 9 && hour < 16, 1)) {  // likely
        return true;
    }
    return false;
}

int main() {
    // ç¼–è¯‘æ—¶ä½¿ç”¨ -O3 -march=native è·å¾—æœ€ä½³æ€§èƒ½
    double prices[] = {100.1, 100.2, 100.3};
    processTickData(prices, 3);

    return 0;
}

/*
ç¼–è¯‘ä¼˜åŒ–æŠ€å·§ï¼š
- ä½¿ç”¨ -O3 ä¼˜åŒ–çº§åˆ«
- ä½¿ç”¨ -march=native å¯ç”¨CPUç‰¹å®šæŒ‡ä»¤
- ä½¿ç”¨ -flto é“¾æ¥æ—¶ä¼˜åŒ–
- ä½¿ç”¨ PGOï¼ˆProfile-Guided Optimizationï¼‰
*/
```

---

### Day 2ï¼šCPUç¼“å­˜å‹å¥½ç¼–ç¨‹

**å­¦ä¹ ç›®æ ‡**ï¼š
- ç†è§£CPUç¼“å­˜å±‚æ¬¡ç»“æ„
- æŒæ¡ç¼“å­˜è¡Œï¼ˆCache Lineï¼‰æ¦‚å¿µ
- å­¦ä¹ é¿å…ä¼ªå…±äº«ï¼ˆFalse Sharingï¼‰
- å®ç°æ•°æ®å±€éƒ¨æ€§ä¼˜åŒ–

**å­¦ä¹ å†…å®¹**ï¼š

#### 1. CPUç¼“å­˜åŸºç¡€

```cpp
// æŸ¥çœ‹CPUç¼“å­˜ä¿¡æ¯
#include <iostream>
#include <chrono>
#include <vector>

void printCacheInfo() {
    std::cout << "=== CPU Cache Information ===" << std::endl;
    std::cout << "L1 Data Cache: typically 32KB per core" << std::endl;
    std::cout << "L1 Instruction Cache: typically 32KB per core" << std::endl;
    std::cout << "L2 Cache: typically 256KB per core" << std::endl;
    std::cout << "L3 Cache: typically 8-32MB shared" << std::endl;
    std::cout << "Cache Line Size: 64 bytes (typical)" << std::endl;
    std::cout << "\nAccess Latency:" << std::endl;
    std::cout << "L1: ~4 cycles (~1ns)" << std::endl;
    std::cout << "L2: ~12 cycles (~3ns)" << std::endl;
    std::cout << "L3: ~40 cycles (~10ns)" << std::endl;
    std::cout << "RAM: ~200 cycles (~60ns)" << std::endl;
}

// æ¼”ç¤ºç¼“å­˜å¯¹æ€§èƒ½çš„å½±å“
void cacheEffectDemo() {
    using namespace std::chrono;
    const int SIZE = 64 * 1024 * 1024;  // 64MBæ•°ç»„

    std::vector<int> arr(SIZE);

    // æµ‹è¯•1ï¼šé¡ºåºè®¿é—®ï¼ˆç¼“å­˜å‹å¥½ï¼‰
    {
        auto start = high_resolution_clock::now();

        long long sum = 0;
        for (int i = 0; i < SIZE; ++i) {
            sum += arr[i];
        }

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end - start);
        std::cout << "Sequential access: " << duration.count() << " ms" << std::endl;
    }

    // æµ‹è¯•2ï¼šéšæœºè®¿é—®ï¼ˆç¼“å­˜ä¸å‹å¥½ï¼‰
    {
        auto start = high_resolution_clock::now();

        long long sum = 0;
        for (int i = 0; i < SIZE; i += 16) {  // è·³è·ƒè®¿é—®
            sum += arr[i];
        }

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end - start);
        std::cout << "Strided access: " << duration.count() << " ms" << std::endl;
    }
}

int main() {
    printCacheInfo();
    std::cout << std::endl;
    cacheEffectDemo();
    return 0;
}

// ç»“è®ºï¼šé¡ºåºè®¿é—®æ¯”è·¨æ­¥è®¿é—®å¿«3-10å€ï¼
```

#### 2. é¿å…ä¼ªå…±äº«ï¼ˆFalse Sharingï¼‰

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <atomic>

// é”™è¯¯ç¤ºä¾‹ï¼šä¼ªå…±äº«é—®é¢˜
struct BadCounter {
    std::atomic<long> count1;  // å‡è®¾åœ¨åŒä¸€ç¼“å­˜è¡Œ
    std::atomic<long> count2;  // å‡è®¾åœ¨åŒä¸€ç¼“å­˜è¡Œ
};

// æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨cache line paddingé¿å…ä¼ªå…±äº«
constexpr size_t CACHE_LINE_SIZE = 64;

struct alignas(CACHE_LINE_SIZE) GoodCounter {
    std::atomic<long> count1;
    char padding1[CACHE_LINE_SIZE - sizeof(std::atomic<long>)];
    std::atomic<long> count2;
    char padding2[CACHE_LINE_SIZE - sizeof(std::atomic<long>)];
};

// æ€§èƒ½å¯¹æ¯”æµ‹è¯•
void testFalseSharing() {
    using namespace std::chrono;
    const int ITERATIONS = 100000000;

    // æµ‹è¯•1ï¼šæœ‰ä¼ªå…±äº«
    {
        BadCounter bad;
        bad.count1 = 0;
        bad.count2 = 0;

        auto start = high_resolution_clock::now();

        std::thread t1([&]() {
            for (int i = 0; i < ITERATIONS; ++i) {
                bad.count1.fetch_add(1, std::memory_order_relaxed);
            }
        });

        std::thread t2([&]() {
            for (int i = 0; i < ITERATIONS; ++i) {
                bad.count2.fetch_add(1, std::memory_order_relaxed);
            }
        });

        t1.join();
        t2.join();

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end - start);
        std::cout << "With false sharing: " << duration.count() << " ms" << std::endl;
    }

    // æµ‹è¯•2ï¼šæ— ä¼ªå…±äº«
    {
        GoodCounter good;
        good.count1 = 0;
        good.count2 = 0;

        auto start = high_resolution_clock::now();

        std::thread t1([&]() {
            for (int i = 0; i < ITERATIONS; ++i) {
                good.count1.fetch_add(1, std::memory_order_relaxed);
            }
        });

        std::thread t2([&]() {
            for (int i = 0; i < ITERATIONS; ++i) {
                good.count2.fetch_add(1, std::memory_order_relaxed);
            }
        });

        t1.join();
        t2.join();

        auto end = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end - start);
        std::cout << "Without false sharing: " << duration.count() << " ms" << std::endl;
    }
}

// äº¤æ˜“ç³»ç»Ÿåº”ç”¨ï¼šè®¢å•ç°¿çš„ç¼“å­˜ä¼˜åŒ–
struct alignas(CACHE_LINE_SIZE) OrderBookLevel {
    double price;
    long volume;
    int orderCount;
    // paddingåˆ°64å­—èŠ‚
    char padding[CACHE_LINE_SIZE - sizeof(double) - sizeof(long) - sizeof(int)];
};

int main() {
    std::cout << "Cache line size: " << CACHE_LINE_SIZE << " bytes" << std::endl;
    std::cout << "sizeof(GoodCounter): " << sizeof(GoodCounter) << " bytes" << std::endl;
    std::cout << std::endl;

    testFalseSharing();

    return 0;
}

// ç»“è®ºï¼šé¿å…ä¼ªå…±äº«å¯ä»¥æå‡2-10å€æ€§èƒ½ï¼
```

---

**ä»Šæ—¥ä½œä¸š**ï¼š
- [ ] å®ç°ä¸€ä¸ªä½å»¶è¿Ÿçš„å¾ªç¯ç¼“å†²åŒºï¼ˆRing Bufferï¼‰
- [ ] å¯¹æ¯”ä¸åŒå®¹å™¨ï¼ˆvector/deque/listï¼‰åœ¨é¡ºåºè®¿é—®å’Œéšæœºè®¿é—®ä¸‹çš„æ€§èƒ½
- [ ] å®ç°ä¸€ä¸ªcache-lineå¯¹é½çš„æ— é”é˜Ÿåˆ—

**ä»Šæ—¥æ£€æŸ¥ç‚¹**ï¼š
- [ ] èƒ½è§£é‡Šç§»åŠ¨è¯­ä¹‰å¦‚ä½•æå‡æ€§èƒ½
- [ ] ç†è§£ä»€ä¹ˆæ˜¯ä¼ªå…±äº«åŠå¦‚ä½•é¿å…
- [ ] çŸ¥é“constexprçš„ä½¿ç”¨åœºæ™¯
- [ ] èƒ½è¯´å‡ºCPUç¼“å­˜çš„å±‚æ¬¡ç»“æ„

---

### Day 3ï¼šå†…å­˜å¯¹é½ä¸æ•°æ®å¸ƒå±€ä¼˜åŒ–

**å­¦ä¹ ç›®æ ‡**ï¼š
- ç†è§£å†…å­˜å¯¹é½çš„é‡è¦æ€§
- æŒæ¡structå¸ƒå±€ä¼˜åŒ–
- å­¦ä¹ SIMDå‹å¥½çš„æ•°æ®å¸ƒå±€

**å­¦ä¹ å†…å®¹**ï¼š

#### 1. å†…å­˜å¯¹é½åŸºç¡€

```cpp
#include <iostream>
#include <cstddef>

// æœªä¼˜åŒ–çš„ç»“æ„ä½“
struct BadOrder {
    char side;        // 1 byte
    double price;     // 8 bytes
    char status;      // 1 byte
    int quantity;     // 4 bytes
    long orderId;     // 8 bytes
};

// ä¼˜åŒ–åçš„ç»“æ„ä½“ï¼ˆå­—æ®µé‡æ’ï¼‰
struct GoodOrder {
    double price;     // 8 bytes
    long orderId;     // 8 bytes
    int quantity;     // 4 bytes
    char side;        // 1 byte
    char status;      // 1 byte
    // ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨paddingåˆ°8å­—èŠ‚å¯¹é½
};

void analyzeAlignment() {
    std::cout << "=== Memory Alignment Analysis ===" << std::endl;

    std::cout << "\nBadOrder:" << std::endl;
    std::cout << "sizeof: " << sizeof(BadOrder) << " bytes" << std::endl;
    std::cout << "alignof: " << alignof(BadOrder) << " bytes" << std::endl;
    std::cout << "offset of side: " << offsetof(BadOrder, side) << std::endl;
    std::cout << "offset of price: " << offsetof(BadOrder, price) << std::endl;
    std::cout << "offset of status: " << offsetof(BadOrder, status) << std::endl;
    std::cout << "offset of quantity: " << offsetof(BadOrder, quantity) << std::endl;
    std::cout << "offset of orderId: " << offsetof(BadOrder, orderId) << std::endl;

    std::cout << "\nGoodOrder:" << std::endl;
    std::cout << "sizeof: " << sizeof(GoodOrder) << " bytes" << std::endl;
    std::cout << "alignof: " << alignof(GoodOrder) << " bytes" << std::endl;

    std::cout << "\nMemory savings: "
              << sizeof(BadOrder) - sizeof(GoodOrder)
              << " bytes per object" << std::endl;
}

// å¼ºåˆ¶å¯¹é½åˆ°64å­—èŠ‚ï¼ˆä¸€ä¸ªç¼“å­˜è¡Œï¼‰
struct alignas(64) CacheLineAlignedOrder {
    double price;
    long orderId;
    int quantity;
    char side;
    char status;
};

int main() {
    analyzeAlignment();

    std::cout << "\nCacheLineAlignedOrder size: "
              << sizeof(CacheLineAlignedOrder) << " bytes" << std::endl;

    return 0;
}
```

#### 2. SIMDå‹å¥½çš„æ•°æ®å¸ƒå±€ï¼ˆAoS vs SoAï¼‰

```cpp
#include <iostream>
#include <vector>
#include <chrono>
#include <immintrin.h>  // AVXæŒ‡ä»¤

// Array of Structures (AoS) - ä¼ ç»Ÿå¸ƒå±€
struct AoS_MarketData {
    double bid;
    double ask;
    double last;
    int volume;
};

// Structure of Arrays (SoA) - SIMDå‹å¥½å¸ƒå±€
struct SoA_MarketData {
    std::vector<double> bids;
    std::vector<double> asks;
    std::vector<double> lasts;
    std::vector<int> volumes;

    SoA_MarketData(size_t size) {
        bids.resize(size);
        asks.resize(size);
        lasts.resize(size);
        volumes.resize(size);
    }
};

// è®¡ç®—VWAPçš„æ€§èƒ½å¯¹æ¯”
void computeVWAP_AoS(const std::vector<AoS_MarketData>& data) {
    double totalValue = 0.0;
    long totalVolume = 0;

    for (const auto& tick : data) {
        totalValue += tick.last * tick.volume;
        totalVolume += tick.volume;
    }

    double vwap = totalValue / totalVolume;
}

void computeVWAP_SoA(const SoA_MarketData& data) {
    double totalValue = 0.0;
    long totalVolume = 0;

    for (size_t i = 0; i < data.lasts.size(); ++i) {
        totalValue += data.lasts[i] * data.volumes[i];
        totalVolume += data.volumes[i];
    }

    double vwap = totalValue / totalVolume;
}

// AVXä¼˜åŒ–ç‰ˆæœ¬ï¼ˆä¸€æ¬¡å¤„ç†4ä¸ªdoubleï¼‰
void computeVWAP_SoA_AVX(const SoA_MarketData& data) {
    __m256d sumValue = _mm256_setzero_pd();
    __m256d sumVolume = _mm256_setzero_pd();

    size_t i = 0;
    for (; i + 3 < data.lasts.size(); i += 4) {
        __m256d prices = _mm256_loadu_pd(&data.lasts[i]);
        __m256d volumes = _mm256_cvtepi32_pd(_mm_loadu_si128((__m128i*)&data.volumes[i]));

        __m256d values = _mm256_mul_pd(prices, volumes);
        sumValue = _mm256_add_pd(sumValue, values);
        sumVolume = _mm256_add_pd(sumVolume, volumes);
    }

    // æ°´å¹³æ±‚å’Œ
    double totalValue[4], totalVol[4];
    _mm256_storeu_pd(totalValue, sumValue);
    _mm256_storeu_pd(totalVol, sumVolume);

    double finalValue = totalValue[0] + totalValue[1] + totalValue[2] + totalValue[3];
    double finalVol = totalVol[0] + totalVol[1] + totalVol[2] + totalVol[3];

    // å¤„ç†å‰©ä½™å…ƒç´ 
    for (; i < data.lasts.size(); ++i) {
        finalValue += data.lasts[i] * data.volumes[i];
        finalVol += data.volumes[i];
    }

    double vwap = finalValue / finalVol;
}

int main() {
    using namespace std::chrono;
    const int N = 10000000;

    // AoSæµ‹è¯•
    std::vector<AoS_MarketData> aosData(N);
    for (int i = 0; i < N; ++i) {
        aosData[i] = {100.0, 100.1, 100.05, 1000};
    }

    auto start = high_resolution_clock::now();
    computeVWAP_AoS(aosData);
    auto end = high_resolution_clock::now();
    auto duration1 = duration_cast<microseconds>(end - start);
    std::cout << "AoS: " << duration1.count() << " Î¼s" << std::endl;

    // SoAæµ‹è¯•
    SoA_MarketData soaData(N);
    for (int i = 0; i < N; ++i) {
        soaData.bids[i] = 100.0;
        soaData.asks[i] = 100.1;
        soaData.lasts[i] = 100.05;
        soaData.volumes[i] = 1000;
    }

    start = high_resolution_clock::now();
    computeVWAP_SoA(soaData);
    end = high_resolution_clock::now();
    auto duration2 = duration_cast<microseconds>(end - start);
    std::cout << "SoA: " << duration2.count() << " Î¼s" << std::endl;

    // AVXä¼˜åŒ–ç‰ˆæœ¬
    start = high_resolution_clock::now();
    computeVWAP_SoA_AVX(soaData);
    end = high_resolution_clock::now();
    auto duration3 = duration_cast<microseconds>(end - start);
    std::cout << "SoA + AVX: " << duration3.count() << " Î¼s" << std::endl;

    std::cout << "\nSpeedup: "
              << (double)duration1.count() / duration3.count() << "x" << std::endl;

    return 0;
}

// ç¼–è¯‘: g++ -std=c++17 -O3 -mavx2 soa.cpp -o soa
// ç»“æœï¼šAVXä¼˜åŒ–ç‰ˆæœ¬å¯ä»¥å¿«4-8å€ï¼
```

---

### Day 4ï¼šä½å»¶è¿Ÿç¼–ç¨‹æŠ€å·§

**å­¦ä¹ å†…å®¹**ï¼š

#### 1. é¿å…åŠ¨æ€å†…å­˜åˆ†é…

```cpp
// ä½¿ç”¨å¯¹è±¡æ± é¿å…é¢‘ç¹new/delete
template<typename T, size_t PoolSize>
class ObjectPool {
private:
    union Node {
        T object;
        Node* next;
    };

    Node pool[PoolSize];
    Node* freeList;

public:
    ObjectPool() {
        freeList = &pool[0];
        for (size_t i = 0; i < PoolSize - 1; ++i) {
            pool[i].next = &pool[i + 1];
        }
        pool[PoolSize - 1].next = nullptr;
    }

    T* allocate() {
        if (!freeList) return nullptr;

        Node* node = freeList;
        freeList = freeList->next;
        return &node->object;
    }

    void deallocate(T* ptr) {
        Node* node = reinterpret_cast<Node*>(ptr);
        node->next = freeList;
        freeList = node;
    }
};

// ä½¿ç”¨ç¤ºä¾‹
struct Order {
    int orderId;
    double price;
    int quantity;
};

ObjectPool<Order, 10000> orderPool;

void processOrders() {
    // ä»æ± ä¸­åˆ†é…ï¼Œé¿å…heapåˆ†é…
    Order* order = orderPool.allocate();
    if (order) {
        order->orderId = 12345;
        order->price = 100.50;
        order->quantity = 1000;

        // ä½¿ç”¨è®¢å•...

        // å½’è¿˜åˆ°æ± 
        orderPool.deallocate(order);
    }
}
```

#### 2. ä½¿ç”¨PMRï¼ˆå¤šæ€å†…å­˜èµ„æºï¼‰

```cpp
#include <memory_resource>
#include <vector>

// ä½¿ç”¨æ ˆå†…å­˜çš„PMRå®¹å™¨
void usePMR() {
    // åœ¨æ ˆä¸Šé¢„åˆ†é…å†…å­˜
    std::byte buffer[4096];
    std::pmr::monotonic_buffer_resource pool{buffer, sizeof(buffer)};

    // ä½¿ç”¨PMR vector
    std::pmr::vector<int> orders(&pool);

    for (int i = 0; i < 100; ++i) {
        orders.push_back(i);  // åœ¨æ ˆä¸Šåˆ†é…ï¼Œè¶…å¿«ï¼
    }

    // ordersç¦»å¼€ä½œç”¨åŸŸï¼Œæ— éœ€é‡Šæ”¾å†…å­˜
}
```

---

### Day 5-7ï¼šå‰©ä½™ç¬¬1å‘¨å†…å®¹

**Day 5**ï¼šåˆ†æ”¯é¢„æµ‹ä¼˜åŒ–
**Day 6**ï¼šå¾ªç¯ä¼˜åŒ–ä¸å‘é‡åŒ–
**Day 7**ï¼šç¬¬1å‘¨æ€»ç»“ä¸é¡¹ç›®

---

## ç¬¬2å‘¨ï¼šåº•å±‚ç³»ç»Ÿä¼˜åŒ–

### Day 8ï¼šLinuxå†…æ ¸å‚æ•°è°ƒä¼˜

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡sysctlå‚æ•°ä¼˜åŒ–
- å­¦ä¹ CPUé¢‘ç‡è°ƒä¼˜
- ç†è§£ä¸­æ–­äº²å’Œæ€§è®¾ç½®

**å­¦ä¹ å†…å®¹**ï¼š

#### 1. ç½‘ç»œå‚æ•°ä¼˜åŒ–

```bash
#!/bin/bash
# ä½å»¶è¿Ÿäº¤æ˜“ç³»ç»Ÿç½‘ç»œä¼˜åŒ–è„šæœ¬

# TCPç¼“å†²åŒºä¼˜åŒ–
sysctl -w net.core.rmem_max=134217728
sysctl -w net.core.wmem_max=134217728
sysctl -w net.ipv4.tcp_rmem="4096 87380 134217728"
sysctl -w net.ipv4.tcp_wmem="4096 65536 134217728"

# å‡å°‘TIME_WAIT socketæ•°é‡
sysctl -w net.ipv4.tcp_tw_reuse=1
sysctl -w net.ipv4.tcp_tw_recycle=1
sysctl -w net.ipv4.tcp_fin_timeout=15

# å¢åŠ socketç›‘å¬é˜Ÿåˆ—
sysctl -w net.core.somaxconn=65535
sysctl -w net.core.netdev_max_backlog=65535

# ç¦ç”¨TCP slow start
sysctl -w net.ipv4.tcp_slow_start_after_idle=0

# å¯ç”¨TCP BBRæ‹¥å¡æ§åˆ¶ï¼ˆä½å»¶è¿Ÿï¼‰
sysctl -w net.core.default_qdisc=fq
sysctl -w net.ipv4.tcp_congestion_control=bbr

echo "Network tuning completed"
```

#### 2. CPUè°ƒä¼˜

```bash
#!/bin/bash
# CPUæ€§èƒ½è°ƒä¼˜

# è®¾ç½®CPUä¸ºperformanceæ¨¡å¼ï¼ˆæœ€é«˜é¢‘ç‡ï¼‰
for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
    echo performance > $cpu/cpufreq/scaling_governor
done

# ç¦ç”¨CPUé¢‘ç‡è°ƒæ•´ï¼ˆä¿æŒæœ€é«˜é¢‘ç‡ï¼‰
echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo

# è®¾ç½®è¿›ç¨‹CPUäº²å’Œæ€§
# å‡è®¾äº¤æ˜“å¼•æ“è¿è¡Œåœ¨PID 1234ï¼Œç»‘å®šåˆ°CPU 0-3
taskset -cp 0-3 1234

# è®¾ç½®å®æ—¶ä¼˜å…ˆçº§ï¼ˆéœ€è¦rootï¼‰
chrt -f -p 99 1234

echo "CPU tuning completed"
```

#### 3. ä¸­æ–­äº²å’Œæ€§ä¼˜åŒ–

```bash
#!/bin/bash
# å°†ç½‘å¡ä¸­æ–­ç»‘å®šåˆ°ç‰¹å®šCPU

NIC="eth0"
IRQ=$(cat /proc/interrupts | grep $NIC | awk '{print $1}' | tr -d ':')

# å°†ç½‘å¡ä¸­æ–­ç»‘å®šåˆ°CPU 0
echo 1 > /proc/irq/$IRQ/smp_affinity

echo "IRQ $IRQ bound to CPU 0"
```

#### 4. Huge Pagesé…ç½®

```bash
#!/bin/bash
# é…ç½®å¤§é¡µå†…å­˜ï¼ˆå‡å°‘TLB missï¼‰

# è®¾ç½®2GBçš„huge pages
echo 1024 > /proc/sys/vm/nr_hugepages

# æŒ‚è½½hugetlbfs
mkdir -p /mnt/huge
mount -t hugetlbfs nodev /mnt/huge

echo "Huge pages configured"
```

**C++ç¨‹åºä½¿ç”¨Huge Pages**ï¼š

```cpp
#include <sys/mman.h>
#include <iostream>

void* allocateHugePages(size_t size) {
    // ä½¿ç”¨2MB huge pages
    void* addr = mmap(nullptr, size,
                     PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,
                     -1, 0);

    if (addr == MAP_FAILED) {
        std::cerr << "Failed to allocate huge pages" << std::endl;
        return nullptr;
    }

    return addr;
}

int main() {
    // åˆ†é…100MBçš„huge pages
    size_t size = 100 * 1024 * 1024;
    void* mem = allocateHugePages(size);

    if (mem) {
        std::cout << "Allocated " << size << " bytes using huge pages" << std::endl;

        // ä½¿ç”¨å†…å­˜...

        munmap(mem, size);
    }

    return 0;
}
```

---

### Day 9ï¼šè¿›ç¨‹/çº¿ç¨‹è°ƒåº¦ä¼˜åŒ–

**å­¦ä¹ å†…å®¹**ï¼š

#### 1. å®æ—¶è°ƒåº¦ç­–ç•¥

```cpp
#include <pthread.h>
#include <sched.h>
#include <iostream>

// è®¾ç½®çº¿ç¨‹ä¸ºå®æ—¶ä¼˜å…ˆçº§
void setRealtimePriority(pthread_t thread, int priority) {
    sched_param param;
    param.sched_priority = priority;  // 1-99ï¼Œ99æœ€é«˜

    int result = pthread_setschedparam(thread, SCHED_FIFO, &param);

    if (result == 0) {
        std::cout << "Set thread to realtime priority: " << priority << std::endl;
    } else {
        std::cerr << "Failed to set realtime priority" << std::endl;
    }
}

// ç»‘å®šçº¿ç¨‹åˆ°ç‰¹å®šCPU
void bindThreadToCPU(pthread_t thread, int cpu) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu, &cpuset);

    int result = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);

    if (result == 0) {
        std::cout << "Bound thread to CPU " << cpu << std::endl;
    } else {
        std::cerr << "Failed to bind thread to CPU" << std::endl;
    }
}

// äº¤æ˜“å¼•æ“çº¿ç¨‹
void* tradingEngineThread(void* arg) {
    // è®¾ç½®å½“å‰çº¿ç¨‹çš„å®æ—¶ä¼˜å…ˆçº§
    pthread_t self = pthread_self();
    setRealtimePriority(self, 99);
    bindThreadToCPU(self, 0);

    // äº¤æ˜“é€»è¾‘...
    while (true) {
        // å¤„ç†è®¢å•
    }

    return nullptr;
}

int main() {
    pthread_t thread;
    pthread_create(&thread, nullptr, tradingEngineThread, nullptr);
    pthread_join(thread, nullptr);

    return 0;
}
```

---

### Day 10-14ï¼šç¬¬2å‘¨å‰©ä½™å†…å®¹

**Day 10**ï¼šNUMAæ¶æ„ä¼˜åŒ–
**Day 11**ï¼šå†…å­˜ç®¡ç†ä¼˜åŒ–
**Day 12**ï¼šç£ç›˜IOä¼˜åŒ–
**Day 13**ï¼šç³»ç»Ÿç›‘æ§å·¥å…·
**Day 14**ï¼šç¬¬2å‘¨æ€»ç»“

---

## ç¬¬3å‘¨ï¼šç½‘ç»œç¼–ç¨‹ä¼˜åŒ–

### Day 15ï¼šTCPé›¶æ‹·è´æŠ€æœ¯

**å­¦ä¹ ç›®æ ‡**ï¼š
- ç†è§£é›¶æ‹·è´åŸç†
- æŒæ¡sendfileã€splice
- å­¦ä¹ mmapç”¨æ³•

**å­¦ä¹ å†…å®¹**ï¼š

#### 1. sendfileé›¶æ‹·è´

```cpp
#include <sys/sendfile.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <iostream>

// ä¼ ç»Ÿæ–¹å¼ï¼šè¯»æ–‡ä»¶->ç”¨æˆ·ç©ºé—´->å†™socketï¼ˆ4æ¬¡æ‹·è´ï¼‰
void traditionalSend(int sockfd, const char* filename) {
    int fd = open(filename, O_RDONLY);
    if (fd < 0) return;

    char buffer[4096];
    ssize_t n;

    while ((n = read(fd, buffer, sizeof(buffer))) > 0) {
        send(sockfd, buffer, n, 0);
    }

    close(fd);
}

// é›¶æ‹·è´æ–¹å¼ï¼šç›´æ¥ä»æ–‡ä»¶->socketï¼ˆ2æ¬¡æ‹·è´ï¼‰
void zerocopy_send(int sockfd, const char* filename) {
    int fd = open(filename, O_RDONLY);
    if (fd < 0) return;

    off_t offset = 0;
    struct stat st;
    fstat(fd, &st);

    // sendfileï¼škernelç›´æ¥ä¼ è¾“ï¼Œæ— éœ€ç”¨æˆ·ç©ºé—´æ‹·è´
    sendfile(sockfd, fd, &offset, st.st_size);

    close(fd);
}
```

#### 2. mmapå†…å­˜æ˜ å°„

```cpp
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <iostream>
#include <cstring>

// ä½¿ç”¨mmapè¯»å–å¸‚åœºæ•°æ®æ–‡ä»¶
struct MarketTick {
    long timestamp;
    double price;
    int volume;
};

void readMarketDataWithMmap(const char* filename) {
    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        std::cerr << "Failed to open file" << std::endl;
        return;
    }

    // è·å–æ–‡ä»¶å¤§å°
    off_t filesize = lseek(fd, 0, SEEK_END);
    lseek(fd, 0, SEEK_SET);

    // å°†æ–‡ä»¶æ˜ å°„åˆ°å†…å­˜
    void* addr = mmap(nullptr, filesize,
                     PROT_READ,
                     MAP_PRIVATE | MAP_POPULATE,  // MAP_POPULATEé¢„åŠ è½½åˆ°å†…å­˜
                     fd, 0);

    if (addr == MAP_FAILED) {
        std::cerr << "mmap failed" << std::endl;
        close(fd);
        return;
    }

    // ç›´æ¥è®¿é—®å†…å­˜ï¼Œæ— éœ€readç³»ç»Ÿè°ƒç”¨
    MarketTick* ticks = static_cast<MarketTick*>(addr);
    size_t count = filesize / sizeof(MarketTick);

    std::cout << "Processing " << count << " ticks..." << std::endl;

    for (size_t i = 0; i < count; ++i) {
        // å¤„ç†tickæ•°æ®
        // std::cout << ticks[i].timestamp << ", "
        //           << ticks[i].price << ", "
        //           << ticks[i].volume << std::endl;
    }

    // è§£é™¤æ˜ å°„
    munmap(addr, filesize);
    close(fd);
}
```

---

### Day 16ï¼šUDPç»„æ’­ï¼ˆMulticastï¼‰

**å­¦ä¹ å†…å®¹**ï¼š

```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <iostream>

// ç»„æ’­å‘é€ç«¯ï¼ˆäº¤æ˜“æ‰€å‘é€å¸‚åœºæ•°æ®ï¼‰
class MulticastSender {
private:
    int sockfd;
    sockaddr_in addr;

public:
    MulticastSender(const char* group, int port) {
        sockfd = socket(AF_INET, SOCK_DGRAM, 0);

        memset(&addr, 0, sizeof(addr));
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr(group);
        addr.sin_port = htons(port);

        // è®¾ç½®TTL
        unsigned char ttl = 64;
        setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));
    }

    void send(const char* data, size_t len) {
        sendto(sockfd, data, len, 0, (sockaddr*)&addr, sizeof(addr));
    }

    ~MulticastSender() {
        close(sockfd);
    }
};

// ç»„æ’­æ¥æ”¶ç«¯ï¼ˆäº¤æ˜“ç³»ç»Ÿæ¥æ”¶å¸‚åœºæ•°æ®ï¼‰
class MulticastReceiver {
private:
    int sockfd;

public:
    MulticastReceiver(const char* group, int port) {
        sockfd = socket(AF_INET, SOCK_DGRAM, 0);

        // å…è®¸å¤šä¸ªè¿›ç¨‹ç»‘å®šåˆ°åŒä¸€ç«¯å£
        int reuse = 1;
        setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

        // ç»‘å®šåˆ°æœ¬åœ°ç«¯å£
        sockaddr_in addr;
        memset(&addr, 0, sizeof(addr));
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port = htons(port);
        bind(sockfd, (sockaddr*)&addr, sizeof(addr));

        // åŠ å…¥ç»„æ’­ç»„
        ip_mreq mreq;
        mreq.imr_multiaddr.s_addr = inet_addr(group);
        mreq.imr_interface.s_addr = htonl(INADDR_ANY);
        setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));

        std::cout << "Joined multicast group: " << group << std::endl;
    }

    ssize_t receive(char* buffer, size_t len) {
        return recvfrom(sockfd, buffer, len, 0, nullptr, nullptr);
    }

    ~MulticastReceiver() {
        close(sockfd);
    }
};

// ä½¿ç”¨ç¤ºä¾‹
int main() {
    const char* MULTICAST_GROUP = "239.255.0.1";
    const int PORT = 5000;

    // å‘é€ç«¯
    MulticastSender sender(MULTICAST_GROUP, PORT);

    // æ¥æ”¶ç«¯
    MulticastReceiver receiver(MULTICAST_GROUP, PORT);

    // å‘é€å¸‚åœºæ•°æ®
    const char* data = "AAPL,150.50,1000";
    sender.send(data, strlen(data));

    // æ¥æ”¶å¸‚åœºæ•°æ®
    char buffer[1024];
    ssize_t n = receiver.receive(buffer, sizeof(buffer));
    if (n > 0) {
        buffer[n] = '\0';
        std::cout << "Received: " << buffer << std::endl;
    }

    return 0;
}
```

---

### Day 17-21ï¼šç¬¬3å‘¨å‰©ä½™å†…å®¹

**Day 17**ï¼šKernel Bypassï¼ˆDPDKå…¥é—¨ï¼‰
**Day 18**ï¼šRDMAåŸºç¡€
**Day 19**ï¼šç½‘ç»œå»¶è¿Ÿæµ‹é‡
**Day 20**ï¼šç½‘ç»œæŠ–åŠ¨ä¼˜åŒ–
**Day 21**ï¼šç¬¬3å‘¨æ€»ç»“

---

## ç¬¬4å‘¨ï¼šæ— é”ç¼–ç¨‹ä¸å¹¶å‘

### Day 22ï¼šC++å†…å­˜æ¨¡å‹

**å­¦ä¹ ç›®æ ‡**ï¼š
- ç†è§£å†…å­˜åºï¼ˆmemory orderï¼‰
- æŒæ¡åŸå­æ“ä½œ
- å­¦ä¹ happen-beforeå…³ç³»

**å­¦ä¹ å†…å®¹**ï¼š

#### 1. å†…å­˜åºè¯¦è§£

```cpp
#include <atomic>
#include <thread>
#include <iostream>

// ç¤ºä¾‹1ï¼šrelaxed - æœ€å¼±çš„ä¿è¯ï¼Œåªä¿è¯åŸå­æ€§
std::atomic<int> counter{0};

void incrementRelaxed() {
    for (int i = 0; i < 1000000; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed);
    }
}

// ç¤ºä¾‹2ï¼šacquire-release - ä¿è¯åŒæ­¥
std::atomic<bool> ready{false};
int data = 0;

void producer() {
    data = 42;
    ready.store(true, std::memory_order_release);  // release
}

void consumer() {
    while (!ready.load(std::memory_order_acquire));  // acquire
    std::cout << "Data: " << data << std::endl;  // ä¿è¯çœ‹åˆ°42
}

// ç¤ºä¾‹3ï¼šseq_cst - é¡ºåºä¸€è‡´æ€§ï¼ˆé»˜è®¤ï¼Œæœ€å¼ºä¿è¯ï¼‰
std::atomic<int> x{0}, y{0};
std::atomic<int> r1{0}, r2{0};

void thread1() {
    x.store(1, std::memory_order_seq_cst);
    r1 = y.load(std::memory_order_seq_cst);
}

void thread2() {
    y.store(1, std::memory_order_seq_cst);
    r2 = x.load(std::memory_order_seq_cst);
}

int main() {
    // ä½¿ç”¨seq_cstä¿è¯r1å’Œr2ä¸ä¼šåŒæ—¶ä¸º0

    std::thread t1(thread1);
    std::thread t2(thread2);

    t1.join();
    t2.join();

    std::cout << "r1 = " << r1 << ", r2 = " << r2 << std::endl;
    // å¯èƒ½ç»“æœï¼š(0,1), (1,0), (1,1)ï¼Œä½†ä¸ä¼šæ˜¯(0,0)

    return 0;
}
```

#### 2. æ€§èƒ½å¯¹æ¯”

```cpp
#include <atomic>
#include <chrono>
#include <iostream>

void benchmarkMemoryOrders() {
    using namespace std::chrono;
    const int ITERATIONS = 10000000;

    std::atomic<int> counter{0};

    // relaxed
    {
        auto start = high_resolution_clock::now();
        for (int i = 0; i < ITERATIONS; ++i) {
            counter.fetch_add(1, std::memory_order_relaxed);
        }
        auto end = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end - start);
        std::cout << "relaxed: " << duration.count() << " ms" << std::endl;
    }

    // seq_cst
    counter = 0;
    {
        auto start = high_resolution_clock::now();
        for (int i = 0; i < ITERATIONS; ++i) {
            counter.fetch_add(1, std::memory_order_seq_cst);
        }
        auto end = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end - start);
        std::cout << "seq_cst: " << duration.count() << " ms" << std::endl;
    }
}

// relaxedæ¯”seq_cstå¿«2-3å€ï¼
// ä½†è¦å°å¿ƒä½¿ç”¨ï¼Œç¡®ä¿ä¸ä¼šå¯¼è‡´æ•°æ®ç«äº‰
```

---

### Day 23ï¼šæ— é”é˜Ÿåˆ—å®ç°

**å­¦ä¹ å†…å®¹**ï¼š

#### å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…æ— é”é˜Ÿåˆ—ï¼ˆSPSCï¼‰

```cpp
#include <atomic>
#include <vector>
#include <iostream>

template<typename T, size_t Size>
class SPSCQueue {
private:
    std::vector<T> buffer;
    alignas(64) std::atomic<size_t> head;
    alignas(64) std::atomic<size_t> tail;

public:
    SPSCQueue() : buffer(Size), head(0), tail(0) {}

    // ç”Ÿäº§è€…è°ƒç”¨
    bool push(const T& item) {
        size_t currentTail = tail.load(std::memory_order_relaxed);
        size_t nextTail = (currentTail + 1) % Size;

        if (nextTail == head.load(std::memory_order_acquire)) {
            return false;  // é˜Ÿåˆ—æ»¡
        }

        buffer[currentTail] = item;
        tail.store(nextTail, std::memory_order_release);

        return true;
    }

    // æ¶ˆè´¹è€…è°ƒç”¨
    bool pop(T& item) {
        size_t currentHead = head.load(std::memory_order_relaxed);

        if (currentHead == tail.load(std::memory_order_acquire)) {
            return false;  // é˜Ÿåˆ—ç©º
        }

        item = buffer[currentHead];
        head.store((currentHead + 1) % Size, std::memory_order_release);

        return true;
    }

    bool empty() const {
        return head.load(std::memory_order_acquire) ==
               tail.load(std::memory_order_acquire);
    }
};

// äº¤æ˜“ç³»ç»Ÿåº”ç”¨ï¼šè®¢å•é˜Ÿåˆ—
struct Order {
    int orderId;
    double price;
    int quantity;
};

SPSCQueue<Order, 10000> orderQueue;

void producerThread() {
    for (int i = 0; i < 1000; ++i) {
        Order order{i, 100.0 + i, 100};
        while (!orderQueue.push(order)) {
            // é˜Ÿåˆ—æ»¡ï¼Œè‡ªæ—‹ç­‰å¾…
        }
    }
}

void consumerThread() {
    Order order;
    int count = 0;

    while (count < 1000) {
        if (orderQueue.pop(order)) {
            // å¤„ç†è®¢å•
            count++;
        }
    }
}
```

---

### Day 24-28ï¼šç¬¬4å‘¨å‰©ä½™å†…å®¹

**Day 24**ï¼šå¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…æ— é”é˜Ÿåˆ—ï¼ˆMPMCï¼‰
**Day 25**ï¼šæ— é”å“ˆå¸Œè¡¨
**Day 26**ï¼šRCUï¼ˆRead-Copy-Updateï¼‰
**Day 27**ï¼šæ— é”æ ˆä¸ABAé—®é¢˜
**Day 28**ï¼šç¬¬4å‘¨æ€»ç»“

---

## ç¬¬5å‘¨ï¼šæ€§èƒ½åˆ†æä¸è°ƒä¼˜

### Day 29ï¼šperfå·¥å…·æ·±åº¦ä½¿ç”¨

**å­¦ä¹ å†…å®¹**ï¼š

```bash
# æ€§èƒ½åˆ†æå¸¸ç”¨å‘½ä»¤

# 1. ç»Ÿè®¡ç¨‹åºæ€§èƒ½
perf stat ./trading_engine

# è¾“å‡ºç¤ºä¾‹ï¼š
# Performance counter stats for './trading_engine':
#      1,234.56 msec task-clock                #    0.999 CPUs utilized
#         1,234      context-switches          #    0.001 M/sec
#            12      cpu-migrations            #    0.000 M/sec
#           456      page-faults               #    0.369 K/sec
# 3,456,789,012      cycles                    #    2.800 GHz
# 2,345,678,901      instructions              #    0.68  insn per cycle
#   456,789,012      branches                  #  370.123 M/sec
#     1,234,567      branch-misses             #    0.27% of all branches

# 2. è®°å½•æ€§èƒ½æ•°æ®
perf record -g ./trading_engine

# 3. æŸ¥çœ‹æŠ¥å‘Š
perf report

# 4. ç”Ÿæˆç«ç„°å›¾
perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg

# 5. ç›‘æ§ç‰¹å®šäº‹ä»¶
perf stat -e cache-misses,cache-references ./trading_engine

# 6. æŸ¥çœ‹CPUä½¿ç”¨çƒ­ç‚¹
perf top

# 7. è®°å½•å‡½æ•°è°ƒç”¨
perf record -e cpu-clock --call-graph dwarf ./trading_engine

# 8. åˆ†æå†…å­˜è®¿é—®
perf mem record ./trading_engine
perf mem report
```

---

### Day 30ï¼šVTuneæ€§èƒ½åˆ†æ

### Day 31-35ï¼šç¬¬5å‘¨å‰©ä½™å†…å®¹

**Day 31**ï¼šç«ç„°å›¾åˆ†æ
**Day 32**ï¼šå¾®åŸºå‡†æµ‹è¯•ï¼ˆGoogle Benchmarkï¼‰
**Day 33**ï¼šç¼“å­˜æ€§èƒ½åˆ†æ
**Day 34**ï¼šåˆ†æ”¯é¢„æµ‹åˆ†æ
**Day 35**ï¼šç¬¬5å‘¨æ€»ç»“

---

## ç¬¬6å‘¨ï¼šæ—¶åºæ•°æ®åº“

### Day 36ï¼šTimescaleDBå®æˆ˜

**å­¦ä¹ å†…å®¹**ï¼š

```sql
-- åˆ›å»ºhypertableï¼ˆæ—¶åºè¡¨ï¼‰
CREATE TABLE market_ticks (
    time        TIMESTAMPTZ NOT NULL,
    symbol      TEXT NOT NULL,
    price       DOUBLE PRECISION,
    volume      BIGINT,
    bid         DOUBLE PRECISION,
    ask         DOUBLE PRECISION
);

-- è½¬æ¢ä¸ºhypertable
SELECT create_hypertable('market_ticks', 'time');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON market_ticks (symbol, time DESC);

-- æ’å…¥æ•°æ®ï¼ˆC++ç¤ºä¾‹ï¼‰
```

```cpp
#include <libpq-fe.h>
#include <iostream>

class TimescaleDBClient {
private:
    PGconn* conn;

public:
    TimescaleDBClient(const char* conninfo) {
        conn = PQconnectdb(conninfo);

        if (PQstatus(conn) != CONNECTION_OK) {
            std::cerr << "Connection failed: " << PQerrorMessage(conn) << std::endl;
        }
    }

    void insertTick(const char* symbol, double price, long volume) {
        const char* query =
            "INSERT INTO market_ticks (time, symbol, price, volume, bid, ask) "
            "VALUES (NOW(), $1, $2, $3, $4, $5)";

        const char* params[5] = {
            symbol,
            std::to_string(price).c_str(),
            std::to_string(volume).c_str(),
            std::to_string(price - 0.01).c_str(),
            std::to_string(price + 0.01).c_str()
        };

        PGresult* res = PQexecParams(conn, query, 5, nullptr,
                                    params, nullptr, nullptr, 0);

        if (PQresultStatus(res) != PGRES_COMMAND_OK) {
            std::cerr << "Insert failed: " << PQerrorMessage(conn) << std::endl;
        }

        PQclear(res);
    }

    ~TimescaleDBClient() {
        PQfinish(conn);
    }
};
```

---

### Day 37-42ï¼šç¬¬6å‘¨å‰©ä½™å†…å®¹

**Day 37**ï¼šInfluxDBä½¿ç”¨
**Day 38**ï¼šKDB+åŸºç¡€
**Day 39**ï¼šæ—¶åºæ•°æ®å‹ç¼©
**Day 40**ï¼šé«˜æ€§èƒ½æŸ¥è¯¢ä¼˜åŒ–
**Day 41**ï¼šæ•°æ®åˆ†åŒºç­–ç•¥
**Day 42**ï¼šç¬¬6å‘¨æ€»ç»“

---

## ç¬¬7å‘¨ï¼šäº¤æ˜“ç³»ç»Ÿæ¶æ„

### Day 43ï¼šè®¢å•æ‰§è¡Œå¼•æ“è®¾è®¡

**å­¦ä¹ å†…å®¹**ï¼š

```cpp
// è®¢å•ç°¿ï¼ˆOrder Bookï¼‰å®ç°
#include <map>
#include <memory>
#include <iostream>

struct Order {
    long orderId;
    char side;  // 'B' or 'S'
    double price;
    int quantity;
    long timestamp;
};

class OrderBook {
private:
    // ä¹°å•ï¼ˆpriceé™åºï¼‰
    std::map<double, std::vector<Order>, std::greater<double>> bids;

    // å–å•ï¼ˆpriceå‡åºï¼‰
    std::map<double, std::vector<Order>> asks;

public:
    // æ·»åŠ è®¢å•
    void addOrder(const Order& order) {
        if (order.side == 'B') {
            bids[order.price].push_back(order);
        } else {
            asks[order.price].push_back(order);
        }
    }

    // åŒ¹é…è®¢å•
    std::vector<std::pair<Order, Order>> matchOrders() {
        std::vector<std::pair<Order, Order>> matches;

        while (!bids.empty() && !asks.empty()) {
            auto& topBid = bids.begin()->second.front();
            auto& topAsk = asks.begin()->second.front();

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥æˆäº¤
            if (topBid.price >= topAsk.price) {
                // æˆäº¤
                int matchQty = std::min(topBid.quantity, topAsk.quantity);

                matches.push_back({topBid, topAsk});

                topBid.quantity -= matchQty;
                topAsk.quantity -= matchQty;

                // ç§»é™¤å®Œå…¨æˆäº¤çš„è®¢å•
                if (topBid.quantity == 0) {
                    bids.begin()->second.erase(bids.begin()->second.begin());
                    if (bids.begin()->second.empty()) {
                        bids.erase(bids.begin());
                    }
                }

                if (topAsk.quantity == 0) {
                    asks.begin()->second.erase(asks.begin()->second.begin());
                    if (asks.begin()->second.empty()) {
                        asks.erase(asks.begin());
                    }
                }
            } else {
                break;
            }
        }

        return matches;
    }

    // è·å–æœ€ä¼˜ä¹°ä»·
    double getBestBid() const {
        return bids.empty() ? 0.0 : bids.begin()->first;
    }

    // è·å–æœ€ä¼˜å–ä»·
    double getBestAsk() const {
        return asks.empty() ? 0.0 : asks.begin()->first;
    }

    // æ‰“å°è®¢å•ç°¿
    void print() const {
        std::cout << "=== Order Book ===" << std::endl;
        std::cout << "Asks:" << std::endl;
        for (const auto& [price, orders] : asks) {
            int totalQty = 0;
            for (const auto& order : orders) {
                totalQty += order.quantity;
            }
            std::cout << "  " << price << " x " << totalQty << std::endl;
        }

        std::cout << "---" << std::endl;

        std::cout << "Bids:" << std::endl;
        for (const auto& [price, orders] : bids) {
            int totalQty = 0;
            for (const auto& order : orders) {
                totalQty += order.quantity;
            }
            std::cout << "  " << price << " x " << totalQty << std::endl;
        }
    }
};
```

---

### Day 44-49ï¼šç¬¬7å‘¨å‰©ä½™å†…å®¹

**Day 44**ï¼šå¸‚åœºæ•°æ®å¤„ç†ï¼ˆtickæ•°æ®ï¼‰
**Day 45**ï¼šLevel 2/Level 3æ•°æ®è§£æ
**Day 46**ï¼šç­–ç•¥å¼•æ“æ¥å£
**Day 47**ï¼šå›æµ‹ç³»ç»Ÿè®¾è®¡
**Day 48**ï¼šå®æ—¶ç›‘æ§ç³»ç»Ÿ
**Day 49**ï¼šç¬¬7å‘¨æ€»ç»“

---

## ç¬¬8å‘¨ï¼šé£æ§ä¸ç›‘æ§

### Day 50-56

**Day 50**ï¼šé£é™©ç®¡ç†ç³»ç»Ÿ
**Day 51**ï¼šå®æ—¶ç›‘æ§ä¸å‘Šè­¦
**Day 52**ï¼šæ—¥å¿—ç³»ç»Ÿè®¾è®¡
**Day 53**ï¼šæ•…éšœæ¢å¤æœºåˆ¶
**Day 54**ï¼šé«˜å¯ç”¨æ¶æ„
**Day 55**ï¼šç¾å¤‡æ–¹æ¡ˆ
**Day 56**ï¼šç¬¬8å‘¨æ€»ç»“

---

## ç¬¬9å‘¨ï¼šRustç¼–ç¨‹ï¼ˆåŠ åˆ†é¡¹ï¼‰

### Day 57-63

**Day 57**ï¼šRuståŸºç¡€è¯­æ³•
**Day 58**ï¼šæ‰€æœ‰æƒä¸å€Ÿç”¨
**Day 59**ï¼šç”Ÿå‘½å‘¨æœŸ
**Day 60**ï¼šRustä¸C++äº’æ“ä½œ
**Day 61**ï¼šé«˜æ€§èƒ½Rust
**Day 62**ï¼šRustå¼‚æ­¥ç¼–ç¨‹
**Day 63**ï¼šç¬¬9å‘¨æ€»ç»“

---

## ç¬¬10å‘¨ï¼šç»¼åˆé¡¹ç›®+é¢è¯•å‡†å¤‡

### Day 64-70ï¼šæœ€åå†²åˆº

**Day 64-67**ï¼šå®Œæ•´äº¤æ˜“ç³»ç»Ÿå®ç°
**Day 68**ï¼šæ€§èƒ½å‹æµ‹ä¸ä¼˜åŒ–
**Day 69**ï¼šé¢è¯•å‡†å¤‡
**Day 70**ï¼šç®€å†ä¼˜åŒ–ä¸æ¨¡æ‹Ÿé¢è¯•

---

## é«˜é¢‘é¢è¯•é¢˜

### 1. å¦‚ä½•ä¼˜åŒ–äº¤æ˜“ç³»ç»Ÿçš„å»¶è¿Ÿï¼Ÿ

**ç­”æ¡ˆ**ï¼š
1. **ç¡¬ä»¶å±‚é¢**ï¼š
   - ä½¿ç”¨ä½å»¶è¿Ÿç½‘å¡ï¼ˆSolarflareã€Mellanoxï¼‰
   - CPUç»‘æ ¸ã€å…³é—­è¶…çº¿ç¨‹
   - ä½¿ç”¨NUMAæ„ŸçŸ¥çš„å†…å­˜åˆ†é…
   - é…ç½®Huge Pages

2. **æ“ä½œç³»ç»Ÿå±‚é¢**ï¼š
   - ä¼˜åŒ–å†…æ ¸å‚æ•°ï¼ˆTCPå‚æ•°ã€ä¸­æ–­äº²å’Œæ€§ï¼‰
   - ä½¿ç”¨å®æ—¶è°ƒåº¦ç­–ç•¥ï¼ˆSCHED_FIFOï¼‰
   - å…³é—­CPUé¢‘ç‡è°ƒæ•´
   - ç¦ç”¨ä¸å¿…è¦çš„å†…æ ¸æ¨¡å—

3. **ç½‘ç»œå±‚é¢**ï¼š
   - Kernel Bypassï¼ˆDPDKã€OpenOnloadï¼‰
   - é›¶æ‹·è´æŠ€æœ¯ï¼ˆsendfileã€mmapï¼‰
   - ç»„æ’­ï¼ˆMulticastï¼‰æ¥æ”¶å¸‚åœºæ•°æ®
   - RDMAï¼ˆInfiniBandï¼‰

4. **ä»£ç å±‚é¢**ï¼š
   - æ— é”ç¼–ç¨‹
   - å¯¹è±¡æ± é¿å…å†…å­˜åˆ†é…
   - ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„
   - åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–
   - SIMDæŒ‡ä»¤ä¼˜åŒ–

5. **æ¶æ„å±‚é¢**ï¼š
   - å…³é”®è·¯å¾„æœ€å°åŒ–
   - é¢„è®¡ç®—ä¸æŸ¥è¡¨
   - å¼‚æ­¥å¤„ç†éå…³é”®è·¯å¾„
   - æ‰¹å¤„ç†ä¼˜åŒ–

---

### 2. è§£é‡Šæ— é”ç¼–ç¨‹çš„åŸç†å’Œåº”ç”¨åœºæ™¯

**ç­”æ¡ˆ**ï¼š

**åŸç†**ï¼š
- ä½¿ç”¨åŸå­æ“ä½œï¼ˆCASï¼‰æ›¿ä»£é”
- é€šè¿‡å†…å­˜åºä¿è¯å¯è§æ€§
- é¿å…çº¿ç¨‹é˜»å¡å’Œä¸Šä¸‹æ–‡åˆ‡æ¢

**åº”ç”¨åœºæ™¯**ï¼š
1. é«˜é¢‘äº¤æ˜“ï¼ˆä½å»¶è¿Ÿè¦æ±‚ï¼‰
2. å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…é˜Ÿåˆ—
3. è®¡æ•°å™¨ã€ç»Ÿè®¡
4. å¿«ç…§è¯»å–

**ä¼˜ç¼ºç‚¹**ï¼š
- ä¼˜ç‚¹ï¼šæ— ç­‰å¾…ã€ä½å»¶è¿Ÿ
- ç¼ºç‚¹ï¼šå¤æ‚åº¦é«˜ã€å®¹æ˜“å‡ºé”™ã€ABAé—®é¢˜

---

### 3. å¦‚ä½•å¤„ç†tickæ•°æ®ï¼Ÿ

**ç­”æ¡ˆ**ï¼š

```cpp
// Tickæ•°æ®å¤„ç†æµæ°´çº¿
class TickProcessor {
public:
    // 1. æ¥æ”¶åŸå§‹æ•°æ®
    void onRawData(const char* data, size_t len) {
        // è§£æ
        // éªŒè¯
        // è½¬å‘åˆ°ä¸‹æ¸¸
    }

    // 2. æ•°æ®æ ‡å‡†åŒ–
    void normalize(Tick& tick) {
        // ä»·æ ¼æ ‡å‡†åŒ–
        // æ—¶é—´æˆ³è½¬æ¢
        // æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
    }

    // 3. è®¡ç®—è¡ç”ŸæŒ‡æ ‡
    void calculateIndicators(const Tick& tick) {
        // VWAP
        // ç§»åŠ¨å¹³å‡
        // æ³¢åŠ¨ç‡
    }

    // 4. å­˜å‚¨
    void store(const Tick& tick) {
        // å†™å…¥æ—¶åºæ•°æ®åº“
        // æ›´æ–°ç¼“å­˜
    }
};
```

---

## å­¦ä¹ èµ„æº

### ä¹¦ç±æ¨è
1. ã€ŠC++ Concurrency in Actionã€‹
2. ã€ŠSystems Performanceã€‹
3. ã€ŠLinux Performance Tuningã€‹
4. ã€ŠDatabase Internalsã€‹

### åœ¨çº¿èµ„æº
1. CPP Reference
2. Mechanical Sympathyåšå®¢
3. LWN.net
4. Intelå¼€å‘è€…æ‰‹å†Œ

---

*æ–‡æ¡£ç‰ˆæœ¬*ï¼šv1.0 Complete
*æ€»å¤©æ•°*ï¼š70å¤©
*åˆ›å»ºæ—¥æœŸ*ï¼š2026-01-30
*ä½œè€…*ï¼šClaude Sonnet 4.5

**ç°åœ¨å¼€å§‹Day 1çš„å­¦ä¹ ï¼Œæœç€é‡åŒ–äº¤æ˜“åç«¯å·¥ç¨‹å¸ˆçš„ç›®æ ‡å‰è¿›ï¼** ğŸš€ğŸ“ˆğŸ’»

